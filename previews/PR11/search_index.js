var documenterSearchIndex = {"docs":
[{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"CurrentModule = ArrayAllocators","category":"page"},{"location":"api/#Application-Programming-Interface-for-ArrayAllocators.jl","page":"ArrayAllocators.jl","title":"Application Programming Interface for ArrayAllocators.jl","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"ArrayAllocators","category":"page"},{"location":"api/#ArrayAllocators.ArrayAllocators","page":"ArrayAllocators.jl","title":"ArrayAllocators.ArrayAllocators","text":"ArrayAllocators\n\nDefines an array allocator interface and concrete array allocators using malloc, calloc, and memory alignment.\n\nExamples\n\nusing ArrayAllocators\n\nArray{UInt8}(malloc, 100)\nArray{UInt8}(calloc, 1024, 1024)\nArray{UInt8}(MemAlign(2^16), (1024, 1024, 16))\n\nSee also NumaAllocators, SafeByteCalculators\n\n\n\n\n\n","category":"module"},{"location":"api/#Allocators","page":"ArrayAllocators.jl","title":"Allocators","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"calloc\nmalloc","category":"page"},{"location":"api/#ArrayAllocators.calloc","page":"ArrayAllocators.jl","title":"ArrayAllocators.calloc","text":"calloc\n\nCallocAllocator singleton instance. calloc will allocate memory and guarantee initialization to 0. See the type for details and the C standard library function for further details.\n\nExample\n\njulia> A = Array{UInt8}(calloc, 16, 16);\n\njulia> sum(A)\n0x0000000000000000\n\n\n\n\n\n","category":"constant"},{"location":"api/#ArrayAllocators.malloc","page":"ArrayAllocators.jl","title":"ArrayAllocators.malloc","text":"malloc\n\nMallocAllocator singleton instance. malloc will only allocate memory. It does not initialize memory is is similar in use as undef. See the type and the C standard library function for details.\n\nExample\n\njulia> Array{UInt8}(malloc, 16, 16);\n\n\n\n\n\n\n","category":"constant"},{"location":"api/#Aligned-Memory","page":"ArrayAllocators.jl","title":"Aligned Memory","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"MemAlign\nalignment\nmin_alignment","category":"page"},{"location":"api/#ArrayAllocators.MemAlign","page":"ArrayAllocators.jl","title":"ArrayAllocators.MemAlign","text":"MemAlign([alignment::Integer])\n\nAllocate aligned memory. Alias for platform specific implementations.\n\nalignment must be a power of 2.\n\nOn POSIX systems, alignment must be a multiple of sizeof(Ptr). On Windows, alignment must be a multiple of 2^16.\n\nIf alignment is not specified, it will be set to min_alignment(MemAlign).\n\nMemAlign is a constant alias for one the following platform specific implementations.\n\nPOSIX (Linux and macOS): POSIX.PosixMemAlign\nWindows: Windows.WinMemAlign.\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.alignment","page":"ArrayAllocators.jl","title":"ArrayAllocators.alignment","text":"alignment(alloc::AbstractMemAlign)\n\nGet byte alignment of the AbstractMemAlign array allocator.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayAllocators.min_alignment","page":"ArrayAllocators.jl","title":"ArrayAllocators.min_alignment","text":"min_alignment(::AbstractMemAlign)\n\nGet the minimum byte alignment of the AbstractMemAlign array allocator.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"ArrayAllocators.jl","title":"Types","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"CallocAllocator\nMallocAllocator\nUndefAllocator","category":"page"},{"location":"api/#ArrayAllocators.CallocAllocator","page":"ArrayAllocators.jl","title":"ArrayAllocators.CallocAllocator","text":"CallocAllocator()\n\nUse Libc.calloc to allocate an array. This is similar to zeros, except that the Libc implementation or the operating system may allocate and zero the memory in a lazy fashion.\n\nSee also https://en.cppreference.com/w/c/memory/calloc .\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.MallocAllocator","page":"ArrayAllocators.jl","title":"ArrayAllocators.MallocAllocator","text":"MallocAllocator()\n\nAllocate array using Libc.malloc. This is not meant to be useful but rather just to prototype the concept for a custom array allocator concept. This should be similar to using undef.\n\nSee also https://en.cppreference.com/w/c/memory/malloc .\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.UndefAllocator","page":"ArrayAllocators.jl","title":"ArrayAllocators.UndefAllocator","text":"UndefAllocator{B}\n\nAllocate arrays using the builtin undef method. The B parameter is a ByteCalculator\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"ArrayAllocators.jl","title":"Internals","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"AbstractArrayAllocator\nAbstractMemAlign\nDefaultByteCalculator\nwrap_libc_pointer","category":"page"},{"location":"api/#ArrayAllocators.AbstractArrayAllocator","page":"ArrayAllocators.jl","title":"ArrayAllocators.AbstractArrayAllocator","text":"AbstractArrayAllocator{B}\n\nParent abstract type for array allocators. Parameter B is an AbstractByteCalculator Defines Array{T}(allocator, dims...) where T = Array{T}(allocator, dims)\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.AbstractMemAlign","page":"ArrayAllocators.jl","title":"ArrayAllocators.AbstractMemAlign","text":"AbstractMemAlign{B} <: AbstractArrayAllocator{B}\n\nAbstract supertype for aligned memory allocators.\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.DefaultByteCalculator","page":"ArrayAllocators.jl","title":"ArrayAllocators.DefaultByteCalculator","text":"DefaultByteCalculator\n\nAlias for ByteCalculators.CheckedMulByteCalculator representing the byte calculator used with subtypes of AbstractArrayAllocator when one is not specified.\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.wrap_libc_pointer","page":"ArrayAllocators.jl","title":"ArrayAllocators.wrap_libc_pointer","text":"wrap_libc_pointer(::Type{A}, ptr::Ptr{T}, dims) where {T, A <: AbstractArray{T}}\nwrap_libc_pointer(ptr::Ptr{T}, dims) where {T, A <: AbstractArray{T}}\n\nChecks to see if ptr is C_NULL for an OutOfMemoryError. Owns the array such that Libc.free is used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Platform-Specific-Interface","page":"ArrayAllocators.jl","title":"Platform Specific Interface","text":"","category":"section"},{"location":"api/#Windows","page":"ArrayAllocators.jl","title":"Windows","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"ArrayAllocators.Windows\nWindows.WinMemAlign\nWindows.MemAddressRequirements\nWindows.MemExtendedParameterAddressRequirements","category":"page"},{"location":"api/#ArrayAllocators.Windows","page":"ArrayAllocators.jl","title":"ArrayAllocators.Windows","text":"ArrayAllocators.Windows\n\nDefines array allocators on Windows.\n\nExamples\n\nusing ArrayAllocators.Windows\n\nArray{UInt8}(WinMemAlign(2^16), 1024)\n\n\n\n\n\n","category":"module"},{"location":"api/#ArrayAllocators.Windows.WinMemAlign","page":"ArrayAllocators.jl","title":"ArrayAllocators.Windows.WinMemAlign","text":"WinMemAlign([alignment, lowestStartingAddress, highestStartingAddress])\n\nUses VirtualAlloc2 to allocate aligned memory. alignment must be a power of 2 and larger than 65536.\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.Windows.MemAddressRequirements","page":"ArrayAllocators.jl","title":"ArrayAllocators.Windows.MemAddressRequirements","text":"MemAddressRequirements\n\nSee https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memaddressrequirements\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayAllocators.Windows.MemExtendedParameterAddressRequirements","page":"ArrayAllocators.jl","title":"ArrayAllocators.Windows.MemExtendedParameterAddressRequirements","text":"MemExtendedParameterAddressRequirements\n\nThis is a Julian structure where the requirements field is Base.RefValue{MemAddressRequirements}\n\nSee https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memextendedparameter\n\nSee also _MemExtendedParameterAddressRequirements\n\n\n\n\n\n","category":"type"},{"location":"api/#POSIX","page":"ArrayAllocators.jl","title":"POSIX","text":"","category":"section"},{"location":"api/","page":"ArrayAllocators.jl","title":"ArrayAllocators.jl","text":"ArrayAllocators.POSIX\nPOSIX.PosixMemAlign","category":"page"},{"location":"api/#ArrayAllocators.POSIX","page":"ArrayAllocators.jl","title":"ArrayAllocators.POSIX","text":"ArrayAllocators.POSIX\n\nDefines ArrayAllocators for POSIX systems such as macOS or Linux.\n\nExample\n\nusing ArrayAllocators.POSIX\n\nArray{UInt16}(PosixMemAlign(), 1024)\n\n\n\n\n\n","category":"module"},{"location":"api/#ArrayAllocators.POSIX.PosixMemAlign","page":"ArrayAllocators.jl","title":"ArrayAllocators.POSIX.PosixMemAlign","text":"PosixMemAlign([alignment::Integer])\n\nUses posix_memalign to allocate aligned memory. alignment must be a power of 2 and larger than sizeof(Ptr).\n\nIf alignment is provided, it will be set to min_alignment(PosixMemAlign).\n\nExample\n\njulia> Array{UInt8}(PosixMemAlign(32), 16, 16);\n\n\n\n\n\n","category":"type"},{"location":"bytecalculators/","page":"Byte Calculators","title":"Byte Calculators","text":"CurrentModule = ArrayAllocators.ByteCalculators","category":"page"},{"location":"bytecalculators/#ByteCalculators","page":"Byte Calculators","title":"ByteCalculators","text":"","category":"section"},{"location":"bytecalculators/","page":"Byte Calculators","title":"Byte Calculators","text":"Byte calculators perform the task of computing the total number of bytes to calculate. In doing so, they try to detect integer overflow conditions.","category":"page"},{"location":"bytecalculators/#Example","page":"Byte Calculators","title":"Example","text":"","category":"section"},{"location":"bytecalculators/","page":"Byte Calculators","title":"Byte Calculators","text":"julia> using ArrayAllocators, ArrayAllocators.ByteCalculators\n\njulia> bc = ArrayAllocators.DefaultByteCalculator{UInt16}(typemax(Int))\nCheckedMulByteCalculator{UInt16}((9223372036854775807,))\n\njulia> length(bc)\n9223372036854775807\n\njulia> nbytes(bc)\nERROR: OverflowError: The product of array length and element size will cause an overflow.\nStacktrace:\n[...]\n\njulia> bc = ByteCalculators.UnsafeByteCalculator{UInt16}(typemax(Int))\nUnsafeByteCalculator{UInt16}((9223372036854775807,))\n\njulia> length(bc)\n9223372036854775807\n\njulia> nbytes(bc)\n-2","category":"page"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"CurrentModule = ArrayAllocators.ByteCalculators","category":"page"},{"location":"bytecalculators_api/#Application-Programming-Interface-for-ArrayAllocators.ByteCalculators","page":"ArrayAllocators.ByteCalculators","title":"Application Programming Interface for ArrayAllocators.ByteCalculators","text":"","category":"section"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"ByteCalculators","category":"page"},{"location":"bytecalculators_api/#ArrayAllocators.ByteCalculators","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"ArrayAllocators.ByteCalculators\n\nDefines calculators for computing the number of bytes needed to allocate an array while detecting integer overflow.\n\nExamples\n\nusing ArrayAllocators.ByteCalculators\n\nbc = CheckedMulByteCalculator{UInt8}(1024, 2048)\nelsize(bc)\nnbytes(bc)\n\n\n\n\n\n","category":"module"},{"location":"bytecalculators_api/#Default-Byte-Calculator","page":"ArrayAllocators.ByteCalculators","title":"Default Byte Calculator","text":"","category":"section"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"CheckedMulByteCalculator","category":"page"},{"location":"bytecalculators_api/#ArrayAllocators.ByteCalculators.CheckedMulByteCalculator","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators.CheckedMulByteCalculator","text":"CheckedMulByteCalculator\n\nCalculate the number of bytes by using Base.checked_mul to check if the product of the dimensions (length) or the product of the length and the element size will cause an integer overflow.\n\n\n\n\n\n","category":"type"},{"location":"bytecalculators_api/#Alternative-Byte-Calculators","page":"ArrayAllocators.ByteCalculators","title":"Alternative Byte Calculators","text":"","category":"section"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"WideningByteCalculator\nUnsafeByteCalculator","category":"page"},{"location":"bytecalculators_api/#ArrayAllocators.ByteCalculators.WideningByteCalculator","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators.WideningByteCalculator","text":"WideningByteCalculator\n\nWidens eltype(Dims), Int in order to catch integer overflow.\n\n\n\n\n\n","category":"type"},{"location":"bytecalculators_api/#ArrayAllocators.ByteCalculators.UnsafeByteCalculator","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators.UnsafeByteCalculator","text":"UnsafeByteCalculator\n\nCalculate number of bytes to allocate for an array without any integer overflow checking.\n\n\n\n\n\n","category":"type"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"CurrentModule = SafeByteCalculators","category":"page"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"SafeByteCalculators\nSafeByteCalculators.SafeByteCalculator","category":"page"},{"location":"bytecalculators_api/#SafeByteCalculators.SafeByteCalculators","page":"ArrayAllocators.ByteCalculators","title":"SafeByteCalculators.SafeByteCalculators","text":"SafeByteCalculators\n\nExtension of ArrayAllocators.ByteCalculators using SaferIntegers.jl.\n\n\n\n\n\n","category":"module"},{"location":"bytecalculators_api/#SafeByteCalculators.SafeByteCalculator","page":"ArrayAllocators.ByteCalculators","title":"SafeByteCalculators.SafeByteCalculator","text":"SafeByteCalculator\n\nUse SafeInt from SaferIntegers.jl to calculate the number of bytes to allocate for an Array.\n\n\n\n\n\n","category":"type"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"CurrentModule = ArrayAllocators.ByteCalculators","category":"page"},{"location":"bytecalculators_api/#Abstract-Type","page":"ArrayAllocators.ByteCalculators","title":"Abstract Type","text":"","category":"section"},{"location":"bytecalculators_api/","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators","text":"AbstractByteCalculator","category":"page"},{"location":"bytecalculators_api/#ArrayAllocators.ByteCalculators.AbstractByteCalculator","page":"ArrayAllocators.ByteCalculators","title":"ArrayAllocators.ByteCalculators.AbstractByteCalculator","text":"AbstractByteCalculator\n\nParent abstract type for byte calculators, which calculate the total number of bytes of memory to allocate.\n\n\n\n\n\n","category":"type"},{"location":"numa_api/","page":"NumaAllocators.jl","title":"NumaAllocators.jl","text":"CurrentModule = NumaAllocators","category":"page"},{"location":"numa_api/#Application-Programming-Interface-for-NumaAllocators.jl","page":"NumaAllocators.jl","title":"Application Programming Interface for NumaAllocators.jl","text":"","category":"section"},{"location":"numa_api/","page":"NumaAllocators.jl","title":"NumaAllocators.jl","text":"NumaAllocators","category":"page"},{"location":"numa_api/#NumaAllocators.NumaAllocators","page":"NumaAllocators.jl","title":"NumaAllocators.NumaAllocators","text":"NumaAllocators\n\nExtends ArrayAllocators to allocate memory on specific NUMA nodes.\n\nExamples\n\nusing NumaAllocators\n\nArray{UInt8}(numa(0), 100)\nArray{UInt8}(NumaAllocator(1), 100)\n\n\n\n\n\n","category":"module"},{"location":"numa_api/#Main-Interface","page":"NumaAllocators.jl","title":"Main Interface","text":"","category":"section"},{"location":"numa_api/","page":"NumaAllocators.jl","title":"NumaAllocators.jl","text":"numa\nNumaAllocator\ncurrent_numa_node\nhighest_numa_node","category":"page"},{"location":"numa_api/#NumaAllocators.numa","page":"NumaAllocators.jl","title":"NumaAllocators.numa","text":"numa(node)\n\nCreate a NumaAllocator on NUMA node node. Short hand for NumaAllocator constructor.\n\nExample\n\njulia> using NumaAllocators\n\njulia> Array{UInt8}(numa(0), 32, 32);\n\n\n\n\n\n","category":"function"},{"location":"numa_api/#NumaAllocators.NumaAllocator","page":"NumaAllocators.jl","title":"NumaAllocators.NumaAllocator","text":"NumaAllocator(node)\n\nCross-platform NUMA allocator\n\nExample\n\njulia> using NumaAllocators\n\njulia> Array{UInt8}(NumaAllocator(0), 32, 32);\n\n\n\n\n\n","category":"type"},{"location":"numa_api/#NumaAllocators.current_numa_node","page":"NumaAllocators.jl","title":"NumaAllocators.current_numa_node","text":"current_numa_node()::Int\n\nReturns the current NUMA node as an Int\n\n\n\n\n\n","category":"function"},{"location":"numa_api/#NumaAllocators.highest_numa_node","page":"NumaAllocators.jl","title":"NumaAllocators.highest_numa_node","text":"highest_numa_node()::Int\n\nReturns the highest NUMA node as an Int\n\n\n\n\n\n","category":"function"},{"location":"numa_api/#Platform-Specific-Interface","page":"NumaAllocators.jl","title":"Platform Specific Interface","text":"","category":"section"},{"location":"numa_api/#Windows","page":"NumaAllocators.jl","title":"Windows","text":"","category":"section"},{"location":"numa_api/","page":"NumaAllocators.jl","title":"NumaAllocators.jl","text":"NumaAllocators.Windows\nNumaAllocators.Windows.WinNumaAllocator","category":"page"},{"location":"numa_api/#NumaAllocators.Windows","page":"NumaAllocators.jl","title":"NumaAllocators.Windows","text":"NumaAllocators.Windows\n\nNUMA support for Windows.\n\nSee also https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocexnuma\n\n\n\n\n\n","category":"module"},{"location":"numa_api/#NumaAllocators.Windows.WinNumaAllocator","page":"NumaAllocators.jl","title":"NumaAllocators.Windows.WinNumaAllocator","text":"WinNumaAllocator\n\nAllocate memory on a specific NUMA node with VirtualAllocExNuma.\n\nSee also https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocexnuma\n\n\n\n\n\n","category":"type"},{"location":"numa_api/#Linux","page":"NumaAllocators.jl","title":"Linux","text":"","category":"section"},{"location":"numa_api/","page":"NumaAllocators.jl","title":"NumaAllocators.jl","text":"NumaAllocators.LibNUMA\nNumaAllocators.LibNUMA.LibNumaAllocator","category":"page"},{"location":"numa_api/#NumaAllocators.LibNUMA","page":"NumaAllocators.jl","title":"NumaAllocators.LibNUMA","text":"NumaAllocators.LibNUMA\n\nNUMA Support for Linux\n\nSee https://github.com/numactl/numactl\n\n\n\n\n\n","category":"module"},{"location":"numa_api/#NumaAllocators.LibNUMA.LibNumaAllocator","page":"NumaAllocators.jl","title":"NumaAllocators.LibNUMA.LibNumaAllocator","text":"LibNumaAllocator{B}\n\nAllocate memory via numa_alloc_onnode.\n\nSee https://linux.die.net/man/3/numa\n\n\n\n\n\n","category":"type"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"CurrentModule = NumaAllocators","category":"page"},{"location":"numa/#NumaAllocators","page":"NUMA Allocators","title":"NumaAllocators","text":"","category":"section"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"Non-Uniform Memory Access (NUMA) array allocators allow you to allocate memory on specific NUMA nodes.","category":"page"},{"location":"numa/#Basic-Usage","page":"NUMA Allocators","title":"Basic Usage","text":"","category":"section"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"A NumaAllocator can be instantiated via numa(node) and passed to the Array constructor as below.","category":"page"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"julia> using NumaAllocators\n\njulia> a0 = Array{Int8}(numa(0), 1024, 1024);\n\njulia> b0 = Array{Int8}(numa(0), 1024, 1024);\n\njulia> a1 = Array{Int8}(numa(1), 1024, 1024);\n\njulia> b1 = Array{Int8}(numa(1), 1024, 1024);","category":"page"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"Depending on your processor architecture, some operations may be between NUMA nodes may be faster than others.","category":"page"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"julia> @time fill!(a0, 1);\n  0.000374 seconds\n\njulia> @time fill!(b0, 2);\n  0.000307 seconds\n\njulia> @time fill!(a1, 3);\n  0.000418 seconds\n\njulia> @time fill!(b1, 4);\n  0.000383 seconds\n\njulia> @time copyto!(b0, a0);\n  0.000439 seconds\n\njulia> @time copyto!(b1, a0);\n  0.000287 seconds\n\njulia> @time copyto!(b1, a1);\n  0.000376 seconds\n\njulia> @time copyto!(b0, a1);\n  0.000455 seconds\n\njulia> current_numa_node()\n0\n\njulia> highest_numa_node()\n1\n\njulia> versioninfo()\nJulia Version 1.7.2\nCommit bf53498635 (2022-02-06 15:21 UTC)\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: Intel(R) Xeon(R) Gold 5220R CPU @ 2.20GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, cascadelake)\n","category":"page"},{"location":"numa/","page":"NUMA Allocators","title":"NUMA Allocators","text":"In the example above, copying 1 MB of data from NUMA node 0 to NUMA node 1 is faster than copying between memory local to either NUMA node or copying data from NUMA node 1 to NUMA node 0.","category":"page"},{"location":"compositions/#Compositions-with-other-packages","page":"Compositions","title":"Compositions with other packages","text":"","category":"section"},{"location":"compositions/#Compositions-that-are-tested","page":"Compositions","title":"Compositions that are tested","text":"","category":"section"},{"location":"compositions/#OffsetArrays.jl","page":"Compositions","title":"OffsetArrays.jl","text":"","category":"section"},{"location":"compositions/","page":"Compositions","title":"Compositions","text":"OffsetArrays.jl allows for the use of shifted indices. Composition is enabled by","category":"page"},{"location":"compositions/","page":"Compositions","title":"Compositions","text":"OffsetArrays implements Base.unsafe_wrap\nAbstractByteCalculators accept AbstractUnitRange arguments","category":"page"},{"location":"compositions/","page":"Compositions","title":"Compositions","text":"julia> using ArrayAllocators, OffsetArrays\n\njulia> OffsetArray{Int}(calloc, -5:5, Base.OneTo(3))\n11×3 OffsetArray(::Matrix{Int64}, -5:5, 1:3) with eltype Int64 with indices -5:5×1:3:\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n 0  0  0\n\njulia> OffsetArray{Int}(calloc, 2, 3)\n2×3 OffsetArray(::Matrix{Int64}, 1:2, 1:3) with eltype Int64 with indices 1:2×1:3:\n 0  0  0\n 0  0  0","category":"page"},{"location":"compositions/#Adding-to-the-list-of-known-compositions","page":"Compositions","title":"Adding to the list of known compositions","text":"","category":"section"},{"location":"compositions/","page":"Compositions","title":"Compositions","text":"Does your package compose well with ArrayAllocators or its subpackages?","category":"page"},{"location":"compositions/","page":"Compositions","title":"Compositions","text":"If so, please let me know by creating an issue.","category":"page"},{"location":"compositions/","page":"Compositions","title":"Compositions","text":"It is important to list known compositions so users know which packages are known to work well together. Additionally, this helps to make sure that packages continue to compose over time. Beyond listing the known composition, I will also add additional tests for them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArrayAllocators","category":"page"},{"location":"#ArrayAllocators","page":"Home","title":"ArrayAllocators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ArrayAllocators.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package provides mechanisms to allocate arrays beyond that provided in the Base module of Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The instances of the sub types of AbstractArrayAllocator take the place of undef in the Array{T}(undef, dims) invocation. This allows us to take advantage of alternative ways of allocating memory. The allocators take advantage of Base.unsafe_wrap in order to create arrays from pointers. A finalizer is also added for allocators that do not use Libc.free.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the base ArrayAllocators package, the following allocators are provided.","category":"page"},{"location":"","page":"Home","title":"Home","text":"calloc\nmalloc\nMemAlign(alignment)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An extension for use with Non-Uniform Memory Access allocations is available via the subpackage NumaAllocators.jl.","category":"page"},{"location":"#Example-Basic-Usage","page":"Home","title":"Example Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each of the methods below allocate 1 MiB of memory. Using undef as the first argument allocate uninitialized memory. The values are not guaranteed to be 0 or any other value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Base, the method zeros can be used to explicitly fill the memory with zeros. This is equivalent to using fill!(..., 0). Using calloc guarantees the values will be 0, yet is often as fast as using undef initialization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ArrayAllocators\n\njulia> @time U = Array{Int8}(undef, 1024, 1024);\n  0.000019 seconds (2 allocations: 1.000 MiB)\n\njulia> @time Z1 = zeros(Int8, 1024, 1024);\n  0.000327 seconds (2 allocations: 1.000 MiB)\n\njulia> @time Z2 = fill!(Array{UInt8}(undef, 1024, 1024), 0);\n  0.000301 seconds (2 allocations: 1.000 MiB)\n\njulia> @time C = Array{Int8}(calloc, 1024, 1024);\n  0.000020 seconds (4 allocations: 1.000 MiB)\n\njulia> sum(C)\n0","category":"page"},{"location":"#Caveats","page":"Home","title":"Caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Above calloc appears to be much faster than zeros at generating an array full of 0s. However, some of the array created with zeros has already been fully allocated. The array allocated with calloc take longer to initialize since the operating system may have deferred the actual allocation of memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @time Z = zeros(Int8, 1024, 1024);\n  0.000324 seconds (2 allocations: 1.000 MiB)\n\njulia> @time fill!(Z, 1);\n  0.000138 seconds\n\njulia> @time fill!(Z, 2);\n  0.000136 seconds\n\njulia> @time U = Array{Int8}(calloc, 1024, 1024);\n  0.000020 seconds (4 allocations: 1.000 MiB)\n\njulia> @time fill!(U, 1);\n  0.000349 seconds\n\njulia> @time fill!(U, 2);\n  0.000136 seconds","category":"page"},{"location":"detailed_overview/#Detailed-Overview","page":"Detailed Overview","title":"Detailed Overview","text":"","category":"section"},{"location":"detailed_overview/","page":"Detailed Overview","title":"Detailed Overview","text":"The original inspiration for this package is the memory allocator calloc. calloc allocates the memory and guarantees that the memory will be initialized by zeros. By this definition, it would appear equivalent to Base.zeros. However, calloc is potentially able to take advantage of operating system facilities that allocate memory lazily on demand rather than eagerly. Additionally, it may be able to obtain memory from the operating system that has already been initialized by zeros due to security constraints. On many systems, this allocator returns as quickly as malloc, the allocator used by Array{T}(undef, dims). In particular, in Python, numpy.zeros uses calloc, which may at times appear faster than Base.zeros in Julia.","category":"page"},{"location":"detailed_overview/","page":"Detailed Overview","title":"Detailed Overview","text":"In contrast, Base.zeros allocates memory using malloc and then uses fill! to eagerly and explicitly fill the array with zeros. On some systems, this may be a redundant operation since the operating system may already know the allocated memory is filled with zeros.","category":"page"},{"location":"detailed_overview/","page":"Detailed Overview","title":"Detailed Overview","text":"This package makes calloc and other allocators available. Some of these allocators are specific to particular kinds of systems.","category":"page"},{"location":"detailed_overview/","page":"Detailed Overview","title":"Detailed Overview","text":"One example is allocating on Non-Uniform Memory Access (NUMA) nodes. On a NUMA system, random-access memory (RAM) may be accessible by certain processor cores at lower latency and higher bandwidth than other cores. Thus, it makes sense to allocate memory on particular NUMA nodes. On Linux, this is facilitated by numactl software which includes libnuma. On Windows, NUMA-aware memory allocation is exposed via the Kernel32 memory application programming interface such as via the function VirtualAllocExNuma. This package provides an abstraction over the two libraries.","category":"page"},{"location":"detailed_overview/","page":"Detailed Overview","title":"Detailed Overview","text":"Another application is memory alignment which may facilitate the use of advanced vector instructions in modern processors.","category":"page"},{"location":"detailed_overview/","page":"Detailed Overview","title":"Detailed Overview","text":"One other feature of this package is implementation of \"Safe\" allocators. These allocators provide extra protection by detecting integer overflow situations. Integer overflow can occur when multiplying large numbers causing the result to potentially wrap around. Memory allocators may report success after allocating an wrapped around number of bytes. The \"Safe\" allocators use the SaferIntegers to detect integer overflow avoiding this erroneous situation.","category":"page"}]
}
